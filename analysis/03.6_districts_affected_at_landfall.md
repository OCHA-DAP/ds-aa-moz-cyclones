---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: .venv
    language: python
    name: python3
---

# Notebook to check which districts are affected at landfall

```python
%load_ext jupyter_black
%load_ext autoreload
%autoreload 2
```

```python
import os
import pandas as pd
from pathlib import Path
import warnings
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize
from matplotlib.cm import ScalarMappable
import numpy as np
import matplotlib.ticker as mticker
import geopandas as gpd
from src.datasources import rsmc, helpers, codab
from src.constants import *
from src.utils import *
```

```python
warnings.filterwarnings("ignore")
```

```python
landfall_df = pd.read_csv(
    AA_DATA_DIR / "public" / "processed" / "moz" / "landfall_time_location.csv"
)
```

```python
adm2_path = (
    AA_DATA_DIR
    / "public"
    / "raw"
    / "moz"
    / "cod_ab"
    / "moz_admbnda_adm2_ine_20190607.shp"
)

gdf_adm2 = gpd.read_file(adm2_path)
adm1_path = (
    AA_DATA_DIR
    / "public"
    / "raw"
    / "moz"
    / "cod_ab"
    / "moz_admbnda_adm1_ine_20190607.shp"
)

gdf_adm1 = gpd.read_file(adm1_path)
gdf_adm1_sel = gdf_adm1[gdf_adm1["ADM1_PT"].isin(ADMS)]
```

```python
df_rsmc = pd.read_parquet(
    rsmc.DATA_DIR
    / "private"
    / "processed"
    / "moz"
    / "rsmc"
    / "rsmc_forecasts_interp_distances_withradius.parquet"
)
df_rsmc_lt0 = df_rsmc[df_rsmc["lt_hour"] == 0]
```

```python
df_rsmc_lt0[df_rsmc_lt0["name"] == "DINEO"]
```

```python
landfall_df.columns
```

Wind Speed

```python
# Convert the date columns to datetime format if they are not already
df_rsmc_lt0["valid_time"] = pd.to_datetime(
    df_rsmc_lt0["valid_time"]
).dt.tz_localize(None)
landfall_df["ISO_TIME"] = pd.to_datetime(landfall_df["ISO_TIME"])

# Step 1: Define the time window around each landfall
time_window = pd.Timedelta(days=0.25)  # Change the number of days as needed

# Step 2: Initialize an empty list to collect filtered data
filtered_data = []

# Step 3: Iterate over each landfall date to filter df_rsmc
for landfall_time in landfall_df["ISO_TIME"]:
    # Define the start and end of the time window
    start_time = landfall_time - time_window
    end_time = landfall_time + time_window

    # Filter df_rsmc for this time window
    filtered = df_rsmc_lt0[
        (df_rsmc_lt0["valid_time"] >= start_time)
        & (df_rsmc_lt0["valid_time"] <= end_time)
    ]

    # Append the filtered data to the list
    filtered_data.append(filtered)

# Step 4: Concatenate all filtered DataFrames into a single DataFrame
final_filtered_df = pd.concat(filtered_data, ignore_index=True)
```

```python
final_filtered_df[final_filtered_df["name"] == "IDAI"]
```

No Buffer

```python
# Step 1: Convert radius from nautical miles to km
final_filtered_df["radius_max_wind_nm"] = pd.to_numeric(
    final_filtered_df["radius_max_wind_nm"], errors="coerce"
)

# Now create the new column for radius in kilometers
final_filtered_df["radius_max_wind_km"] = (
    final_filtered_df["radius_max_wind_nm"] * KPH2KNOTS
)

# Step 2: Create a GeoDataFrame for the storm locations (without buffer)
storm_gdf_no_buffer = gpd.GeoDataFrame(
    final_filtered_df,
    geometry=gpd.points_from_xy(
        final_filtered_df["longitude"], final_filtered_df["latitude"]
    ),
    crs="EPSG:4326", 
)

# Step 3: Perform a spatial join to find which districts intersect with the storm points directly (no buffer)
districts_within_radius_no_buffer = gpd.sjoin(
    gdf_adm2,
    storm_gdf_no_buffer,
    how="inner",
    predicate="intersects",
)

# Step 4: Filter for districts where ADM1_PT is in ADMS
districts_filtered = districts_within_radius_no_buffer[
    districts_within_radius_no_buffer["ADM1_PT"].isin(ADMS)
]

# Step 5: Count the number of unique admin 2 districts for each storm location and time step (without buffer)
district_count_no_buffer = (
    districts_filtered.groupby(["name", "valid_time", "max_wind_kt"])
    .agg({"ADM2_PT": "nunique"})
    .reset_index()
)

district_count_no_buffer.columns = [
    "name",
    "valid_time",
    "max_wind_kt",
    "district_count",
]  # Rename for clarity

# Step 6: Calculate the overall average number of districts across all time steps (no buffer)
average_districts_no_buffer = district_count_no_buffer["district_count"].mean()

# Step 7: Print the results
print("District Count by Storm and Time Step (Without Buffer):")
print(district_count_no_buffer)

print(
    f"\nOverall Average Number of Districts Without Buffer: {average_districts_no_buffer:.0f}"
)
```

With Buffer

```python
# Step 1: Convert radius from nautical miles to km
final_filtered_df["radius_max_wind_nm"] = pd.to_numeric(
    final_filtered_df["radius_max_wind_nm"], errors="coerce"
)

# Now create the new column for radius in kilometers
final_filtered_df["radius_max_wind_km"] = (
    final_filtered_df["radius_max_wind_nm"] * KPH2KNOTS
)

# Step 2: Create a GeoDataFrame for the storm locations
storm_gdf = gpd.GeoDataFrame(
    final_filtered_df,
    geometry=gpd.points_from_xy(
        final_filtered_df["longitude"], final_filtered_df["latitude"]
    ),
    crs="EPSG:4326", 
)

# Step 3: Create buffers around the storm points (with a very small tolerance to keep the point)
storm_gdf["buffer"] = storm_gdf.geometry.buffer(
    storm_gdf["radius_max_wind_km"] / KMS2DEGREE
    + 0.0001  # Small addition ensures the point stays within the buffer
)

# Step 4: Perform a spatial join to find which districts intersect with the buffered areas for all storms
districts_within_radius_all = gpd.sjoin(
    gdf_adm2,
    storm_gdf.set_geometry("buffer"),
    how="inner",
    predicate="intersects",
)

# Step 5: Filter for districts where ADM1_PT is in ADMS
districts_filtered_all = districts_within_radius_all[
    districts_within_radius_all["ADM1_PT"].isin(ADMS)
]

# Step 6: Count the number of unique admin 2 districts for each storm location and time step (all wind speeds)
district_count_all = (
    districts_filtered_all.groupby(["name", "valid_time", "max_wind_kt"])
    .agg({"ADM2_PT": "nunique"})
    .reset_index()
)

district_count_all.columns = [
    "name",
    "valid_time",
    "max_wind_kt",
    "district_count",
]

# Step 7: Filter for wind speeds above 48 knots
storm_gdf_filtered = storm_gdf[storm_gdf["max_wind_kt"] > 48]

# Step 8: Perform a spatial join to find which districts intersect with the buffered areas (wind speed > 48 knots)
districts_within_radius_filtered = gpd.sjoin(
    gdf_adm2,
    storm_gdf_filtered.set_geometry("buffer"),
    how="inner",
    predicate="intersects",
)

# Step 9: Filter for districts where ADM1_PT is in ADMS
districts_filtered_filtered = districts_within_radius_filtered[
    districts_within_radius_filtered["ADM1_PT"].isin(ADMS)
]

# Step 10: Count the number of unique admin 2 districts for each storm location and time step (wind speed > 48 knots)
district_count_filtered = (
    districts_filtered_filtered.groupby(["name", "valid_time", "max_wind_kt"])
    .agg({"ADM2_PT": "nunique"})
    .reset_index()
)

district_count_filtered.columns = [
    "name",
    "valid_time",
    "max_wind_kt",
    "district_count",
]

# Step 11: Calculate the overall average number of districts across all time steps for both cases
average_districts_all = district_count_all["district_count"].mean()
average_districts_filtered = district_count_filtered["district_count"].mean()

# Step 12: Print the results
print(
    f"\nOverall Average Number of Districts within Radius (All Wind Speeds): {average_districts_all:.0f}"
)

print(
    f"\nOverall Average Number of Districts within Radius (Wind Speed > 48 knots): {average_districts_filtered:.0f}"
)
```

```python
district_count_all
```

```python
district_count_filtered
```

```python
# Step 1: Filter storm_gdf to exclude points with longitude above 50
filtered_storm_gdf = storm_gdf[storm_gdf["longitude"] <= 50]

# Step 2: Create buffers for the filtered storm points
filtered_storm_gdf["buffer"] = filtered_storm_gdf.geometry.buffer(
    filtered_storm_gdf["radius_max_wind_km"] / KMS2DEGREE + 0.0001
)

# Step 3: Perform a spatial join to find districts that intersect with the storm buffers
districts_within_buffer = gpd.sjoin(
    gdf_adm2,
    filtered_storm_gdf.set_geometry("buffer"),
    how="inner",
    predicate="intersects",
)

# Step 4: Perform a spatial join to find districts that intersect with the storm landfall points
districts_with_landfall = gpd.sjoin(
    gdf_adm2,
    filtered_storm_gdf,
    how="inner",
    predicate="intersects",
)

# Combine both intersections to get unique highlighted districts
highlighted_districts = pd.concat(
    [districts_within_buffer, districts_with_landfall]
)["ADM2_PT"].unique()

# Step 5: Set up the plot
fig, ax = plt.subplots(figsize=(9, 10))

# Step 6: Plot ADM2 districts with different colors
gdf_adm2.plot(
    ax=ax, color="lightgray", edgecolor="black", alpha=0.5
)  # All districts

# Highlight only the districts that are within the storm buffers or touched by landfall points
gdf_adm2[gdf_adm2["ADM2_PT"].isin(highlighted_districts)].plot(
    ax=ax, color="orange", edgecolor="black", alpha=0.5
)

# Step 7: Plot ADM1 districts with no fill and thicker borders
gdf_adm1_sel.plot(
    ax=ax, edgecolor="black", linewidth=2.5, facecolor="none"
)  # Thick borders, no fill

# Step 8: Plot landfall locations, their radii, and annotate with cyclone names
for idx, row in filtered_storm_gdf.iterrows():
    # Set radius and ensure it's at least 1 km
    radius = row["radius_max_wind_km"] / KMS2DEGREE  # Convert km to degrees

    # Plot the landfall location
    plt.scatter(
        row["longitude"],  # Longitude of the landfall
        row["latitude"],  # Latitude of the landfall
        color="red",
        s=50,
        label=(
            "Landfall" if idx == 0 else ""
        ),  # Add label only for the first point
    )

    # Annotate with the cyclone name
    plt.annotate(
        row["name"],  # Cyclone name
        (row["longitude"], row["latitude"]),
        textcoords="offset points",
        xytext=(0, 5),  # Move text slightly above the point
        ha="center",
        fontsize=8,
        color="black",
    )

    # Plot a circle for the radius of max wind in km
    circle = plt.Circle(
        (row["longitude"], row["latitude"]),
        radius,
        color="blue",
        alpha=0.3,
        label=(
            "Radius of Max Wind" if idx == 0 else ""
        ),  # Add label only for the first circle
    )
    ax.add_patch(circle)

# Add labels and title
plt.title("Storm Landfall Locations with Radius of Max Wind", fontsize=15)
plt.xlabel("Longitude", fontsize=12)
plt.ylabel("Latitude", fontsize=12)

# Set legend position to bottom right
plt.legend()

# Set equal aspect ratio to ensure circles appear circular
ax.set_aspect("equal", adjustable="datalim")
plt.xlim(
    filtered_storm_gdf["longitude"].min() - 5,
    filtered_storm_gdf["longitude"].max() + 5,
)  # Adjust limits if necessary
plt.ylim(
    filtered_storm_gdf["latitude"].min() - 5,
    filtered_storm_gdf["latitude"].max() + 5,
)  # Adjust limits if necessary

# Display the plot
plt.show()
```

Rainfall

```python
# Step 1: Calculate the buffer distance in degrees (250 km / 110 km/degree)
buffer_distance_degrees = (
    250 / KMS2DEGREE
)  # Approximate conversion from km to degrees

# Step 2: Create a GeoDataFrame for landfall points
landfall_gdf = gpd.GeoDataFrame(
    landfall_df,
    geometry=gpd.points_from_xy(landfall_df["LON"], landfall_df["LAT"]),
    crs="EPSG:4326",  # Assuming the original CRS is in WGS84 (EPSG:4326)
)

# Step 3: Buffer each landfall point by the calculated distance
landfall_gdf["buffer"] = landfall_gdf.geometry.buffer(buffer_distance_degrees)

# Step 4: Perform a spatial join to find which districts intersect with the buffered areas
districts_within_buffer = gpd.sjoin(
    gdf_adm2,
    landfall_gdf.set_geometry("buffer"),
    how="inner",
    predicate="intersects",
)

# Step 5: Filter districts to include only those in ADMS
filtered_districts = districts_within_buffer[
    districts_within_buffer["ADM1_PT_left"].isin(ADMS)
]

# Step 6: Count the number of districts for each landfall
district_count_per_landfall = (
    filtered_districts.groupby("NAME")
    .size()
    .reset_index(name="district_count")
)

# Step 7: Calculate the average number of districts across all landfalls
average_districts = district_count_per_landfall["district_count"].mean()

# Print the average number of districts
print(
    f"Average number of districts within 250 km of landfalls: {average_districts:.0f}"
)
```

```python
district_count_per_landfall
```

```python
# Step 5: Plotting

# Create a new figure and axis
fig, ax = plt.subplots(figsize=(8, 10))

# Plot the administrative boundaries (ADM2)
gdf_adm2.plot(ax=ax, color="lightgray", edgecolor="black", alpha=0.5)


# Plot the districts that intersect with the buffer, only those in ADMS
districts_within_buffer[
    districts_within_buffer["ADM1_PT_left"].isin(ADMS)
].plot(ax=ax, color="orange", edgecolor="red", alpha=0.7)

# Plot the buffer around the storm point
landfall_gdf.set_geometry("buffer").plot(ax=ax, color="blue", alpha=0.1)

# Plot the landfall points (storm location)
landfall_gdf.plot(ax=ax, color="red", markersize=50, label="Storm Landfall")
gdf_adm1_sel.plot(
    ax=ax, edgecolor="black", linewidth=2.5, facecolor="none"
)  # Thick borders, no fill

# Adding labels and title
plt.title(
    "250 km Radius Buffer around Storm Landfall with ADM2 Districts",
    fontsize=15,
)
plt.xlabel("Longitude", fontsize=12)
plt.ylabel("Latitude", fontsize=12)
plt.legend()

# Display the plot
plt.show()
```

```python
# Filter for a specific storm (replace 'Storm_Name' with the actual storm name)
storm_name = "FREDDY"  # Replace with the actual storm name

# Step 5: Plotting

# Create a new figure and axis
fig, ax = plt.subplots(figsize=(8, 10))

# Plot the administrative boundaries (ADM2)
gdf_adm2.plot(ax=ax, color="lightgray", edgecolor="black", alpha=0.5)

# Filter districts within buffer for the specific storm
districts_within_buffer_specific = districts_within_buffer[
    districts_within_buffer["NAME"].isin(
        landfall_gdf[landfall_gdf["NAME"] == storm_name]["NAME"]
    )
]

# Plot the districts that intersect with the buffer, only those in ADMS
districts_within_buffer_specific[
    districts_within_buffer_specific["ADM1_PT_left"].isin(ADMS)
].plot(ax=ax, color="orange", edgecolor="black", alpha=0.5)

# Filter landfall_gdf for the specific storm
landfall_gdf_specific = landfall_gdf[landfall_gdf["NAME"] == storm_name]

# Plot the buffer around the storm point
landfall_gdf_specific.set_geometry("buffer").plot(
    ax=ax, color="blue", alpha=0.1
)

# Plot the landfall points (storm location)
landfall_gdf_specific.plot(
    ax=ax, color="red", markersize=50, label="Storm Landfall"
)

# Plot the ADM1 boundaries with thick borders, no fill
gdf_adm1_sel.plot(
    ax=ax, edgecolor="black", linewidth=2.5, facecolor="none"
)  # Thick borders, no fill

# Adding labels and title
plt.title(
    f"250 km Radius Buffer around {storm_name} with ADM2 Districts",
    fontsize=15,
)
plt.xlabel("Longitude", fontsize=12)
plt.ylabel("Latitude", fontsize=12)
plt.legend()

# Display the plot
plt.show()
```
