---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: .venv
    language: python
    name: python3
---

# Processing INAM rainfall data


This notebook reads in the geotiffs provided by INAM via Gabriela, WFP and produces values around the landfall date and 250km around the landfall location.

```python
%load_ext jupyter_black
%load_ext autoreload
%autoreload 2
```

```python
import os
import pandas as pd
from dotenv import load_dotenv
from pathlib import Path
import geopandas as gpd
import rioxarray as rxr
import numpy as np
import warnings
from shapely.geometry import Point
from datetime import timedelta
from src.constants import *
from src.utils import *
from src.datasources import rsmc, helpers

load_dotenv()
```

```python
warnings.filterwarnings("ignore")
```

```python
adm1_path = (
    AA_DATA_DIR
    / "public"
    / "raw"
    / "moz"
    / "cod_ab"
    / "moz_admbnda_adm1_ine_20190607.shp"
)

gdf_adm1 = gpd.read_file(adm1_path)
gdf_sel = gdf_adm1[gdf_adm1.ADM1_PT.isin(ADMS)]
ibtracs_path = (
    Path(AA_DATA_DIR)
    / "public"
    / "raw"
    / "glb"
    / "ibtracs"
    / "IBTrACS.SI.list.v04r01.points/IBTrACS.SI.list.v04r01.points.shp"
)
gdf_ibtracs = gpd.read_file(ibtracs_path)
adm2_path = (
    AA_DATA_DIR
    / "public"
    / "raw"
    / "moz"
    / "cod_ab"
    / "moz_admbnda_adm2_ine_20190607.shp"
)

gdf_adm2 = gpd.read_file(adm2_path)
gdf_sel_adm2 = gdf_adm2[gdf_adm2.ADM1_PT.isin(ADMS)]

minx, miny, maxx, maxy = gdf_sel.total_bounds
```

```python
all_storms = [
    "FAVIO",
    "JOKWE",
    "IZILDA",
    "DANDO",
    "IRINA",
    "HARUNA",
    "DELIWE",
    "GUITO",
    "HELLEN",
    "CHEDZA",
    "DINEO",
    "DESMOND",
    "IDAI",
    "KENNETH",
    "CHALANE",
    "ELOISE",
    "GUAMBE",
    "ANA",
    "GOMBE",
    "JASMINE",
    "FREDDY",
    "FILIPO",
]
```

```python
gdf_sel.plot()
```

```python
landfall_df = pd.read_csv(
    AA_DATA_DIR
    / "public"
    / "processed"
    / "moz"
    / "landfall_time_location_fixed.csv"
)
inam_path = (
    AA_DATA_DIR
    / "private"
    / "raw"
    / "moz"
    / "inam"
    / "OCHA_blended_moz_updated"
    / "OCHA_blended_moz"
)
```

```python
inam_files = files = os.listdir(inam_path)
```

```python
inam_files[0].split("_")[-1].split(".")[0]
```

```python
da_in = rxr.open_rasterio(
    inam_path / "chirp_daily_blended_moz_20030101.tif", masked=True
)
```

```python
da_in
```

```python
da_in.plot()
```

```python
# Initialize the output DataFrame
output_df = pd.DataFrame(
    columns=["NAME", "date", "days_to_landfall", "median_rainfall"]
)

# Define the number of days to look around each point's date
days_range = 5  # Adjust this as needed

# Loop through each cyclone (NAME)
for cyclone in landfall_df["NAME"].unique():
    cyclone_df = landfall_df[landfall_df["NAME"] == cyclone].copy()
    cyclone_df["date"] = pd.to_datetime(cyclone_df["date"], dayfirst=True)

    # Find the landfall date (the date when 'actual_within_land' is True)
    landfall_date = cyclone_df[cyclone_df["actual_within_land"]].iloc[0][
        "date"
    ]
    print(cyclone)
    # Process each date for the cyclone
    for index, row in cyclone_df.iterrows():
        # Determine the date range to search for TIF files
        start_date = row["date"] - timedelta(days=days_range)
        end_date = row["date"] + timedelta(days=days_range)
        # Loop through all TIF files in inam_path
        for tif_file in os.listdir(inam_path):
            # Extract date from TIF filename assuming 'chirp_daily_blended_moz_YYYYMMDD.tif' format
            tif_date_str = tif_file.split("_")[-1].split(".")[0]
            tif_date = pd.to_datetime(tif_date_str, format="%Y%m%d")

            # Process the TIF file if its date falls within the desired range
            if start_date <= tif_date <= end_date:
                tif_path = os.path.join(inam_path, tif_file)

                # Compute the median rainfall within the 250km radius
                median_rainfall = get_median_rainfall(
                    tif_path, row["LON"], row["LAT"], 250, gdf_sel
                )

                # Calculate days to landfall
                days_to_landfall = (tif_date - landfall_date).days

                # Create a temporary DataFrame to store the result
                temp_df = pd.DataFrame(
                    {
                        "NAME": [cyclone],
                        "date": [tif_date],  # Use TIF file's date here
                        "days_to_landfall": [
                            days_to_landfall
                        ],  # Calculate days to landfall
                        "median_rainfall": [median_rainfall],
                    }
                )

                # Append the temporary DataFrame to the output DataFrame using pd.concat
                output_df = pd.concat([output_df, temp_df], ignore_index=True)
```

```python
output_df
```

```python
output_df.to_csv(
    AA_DATA_DIR
    / "public"
    / "processed"
    / "moz"
    / "inam_cyclone_landfall_data_updated.csv"
)
```
